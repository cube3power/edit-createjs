Architectural overview (as far i have grokked it).

-> edit.js: Drupal.behaviour setting up the whole thing.

  -> instatiates -> Drupal.edit.views.OverlayView (bind to Drupal.state.isViewing)
  -> finds all "entities" / "editables" via SparkEditService.js (entity => e.g. "node", predicates => e.g. individual fields/properties on "entity"/node)
    -> instantiates a series of Drupal.edit.views.EditableFieldView or Drupal.edit.views.FormEditableFieldView (extending ultimately Backbone.View) (->views.js)

-> SparkEditService.js: VIE-Service that allows VIE to "find" editable entities (and fields) based on edit.module-markup (instead of e.g. rdfa)
  -> VIE: parses / determines entities (reads/parses/exposes - bridges to "semantic" web w/ backbone)
  -> createjs: leverages VIE-entities to make those editable and "writable" (bridges vie<->backbone<->wysiwyg incl. jquery).

-> views.js: Contains Backbone.Views
  -> views.js: Drupal.edit.views.OverlayView (bound to Drupal.state.isViewing-changes).

  FieldViews:
  -> views.js: Drupal.edit.views.EditableFieldView
    Direct Editable or Direct Editable with Wysiwyg (no server-side form loaded for input).
    @todo: doesn't fully work yet.

  -> views.js: Drupal.edit.views.FormEditableFieldView
    each instantiates in .startEditable (bound to Drupal.state.isViewing-changes) via
    jQuery.createEditable() -> Drupal.createEditable (extending jQuery.Midgard.midgardEditable)
    The editable then the appropriate widget / "editor"
      -> lib/create.js: 'editWidget', lib/create.js: 'alohaWidget'
      -> formwidget.js: Drupal.drupalFormWidget (handles loading and injecting the form via ui-editables.js:Drupal.edit.form.create())

    views.js binds events from Editable
    views.js: .saveClicked -> handles "form" submits via ui-editables.js:Drupal.edit.form.save())

-> editable.js: Drupal.createEditable extends jQuery.Midgard.midgardEditable (Jquery-Widget)
   handles which editor:
    -> "createjs": "direct" -> "editWidget", "directWysiwyg" -> alohaWidget
    -> "Drupal": "form"->"drupalFormWidget" (-> formwidget.js)

-> formwidget.js: Drupal.drupalFormWidget extends jQuery.Create.editWidget (Jquery-Widget)
   handles Drupal Form

-> ui-editables.js: Drupal.edit.toolbar (@todo: refactor -> Drupal.edit.views.ToolbarView as a subview of Drupal.edit.views.FieldView?)
-> ui-editables.js: Drupal.edit.form - initial refactoring of the Ajax loading and saving.

-> ajax.js: currently only contains: Drupal.ajax.prototype.commands.edit_field_rendered_without_transformation_filters which i don't entirely understand (i know it has to do with the wysiwyg).

TODO:
- Turn around the instantiation chain: currently Views instantiating Editables, instead Editables instantiating Views.
- Refactor - ui-editables.js
  a) ToolbarView instances should replace Drupal.edit.toolbar.
  b) split Drupal.edit.form in a meaningful way (and kill ajax.js).
  One way would be to introduce new editor-specific widgets in addition to Drupal.drupalFormWidget add Drupal.drupalEditWidget?, Drupal.drupalAlohaWidget?
  that encapsulate the different way of "saving".
- Backbone.sync - well, how do we do this for extra points? How to map/save


Models
-> Drupal.edit.StateModel
    isViewing: true,  // View, Quick Edit - triggers OverlayView and start/stopEditable in the Views.
    entityBeingHighlighted: [],
    fieldBeingHighlighted: [],
    fieldBeingEdited: [],
    highlightedEditable: null,
    editedEditable: null,
    editedFieldView: null,
    queues: {},
    wysiwygReady: false

-> VIE? What does it have? Brief description

- Events - what's going where?


